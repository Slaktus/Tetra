# Tetra
### An opinion on how to make games in Unity
---
### Overview
Tetra is a framework that abstracts away a lot of Unity's rather opinionated coding style and replaces it with _my_ rather opinionated coding style. It also features stand-alone components that can be used outside the rest of the framework. It provides simple, allocation-free solutions for common problems in something approaching idiomatic modern C#.

In short, the goal of Tetra is to no longer have to write `using UnityEngine;` at the top of your classes.

### Features

+ Caching
+ Collections
+ 2D Collision detection and resolution
+ Command system
+ Entity and session management
+ Game management
+ Rendering
+ Splines
+ Timing
+ Tweening
+ UI management

### Caching
The only caching solution is a very simple generic pool. 

#### Pool
Instances are generated by a delegate and stored on a stack. The pool features an abstract subclass so pools can be handled generically, but a type argument is necessary to both get and put instances. The pool automatically resizes if the pool is empty and an instance is requested.

_Usage:_

```C#
Pool<PooledType> pool = new Pool<Type>(() => new PooledType(), capacity)
PooledType pooledType = pool.Get();
pool.Put(pooledType);
```

### Collections
The only new collection is a simple, `List<T>`-backed PriorityQueue.

#### PriorityQueue
Useful for algorithms like A*, a priority queue takes an instance and an associated priority, and the new instance is automatically sorted into the queue by priority.

_Usage:_

```C#
PriorityQueue<QueuedType> priorityQueue = new PriorityQueue<QueuedType>(capacity);

QueuedType instanceA = new QueuedType();
QueuedType instanceB = new QueuedType();
QueuedType instanceC = new QueuedType();

priorityQueue.Enqueue(instanceA, 3);
priorityQueue.Enqueue(instanceB, 1);
priorityQueue.Enqueue(instanceC, 2);

QueuedType peekedInstanceB = priorityQueue.Peek();

QueuedType dequeuedInstanceB = priorityQueue.Dequeue();
QueuedType dequeuedInstanceC = priorityQueue.Dequeue();
QueuedType dequeuedInstanceA = priorityQueue.Dequeue();
```

### 2D Collision
A fast and simple collision detection system based on the separating axis theorem (SAT) that depends on Unity's SIMD-optimized mathematics library (https://github.com/Unity-Technologies/Unity.Mathematics). It features a static class that resolves:

+ AABB intersection
+ Raycasting against colliders
+ Point contained by AABB/collider
+ Collider intersects another collider
+ Collider contained by another collider
+ Depenetration of two intersecting colliders

for the following:

+ Circles
+ Polygons
+ Rectangles

It also features a collision system that groups colliders by a given type and uses a simple space partitioning broad phase and an AABB narrow phase to efficiently prune the number of tests necessary to determine intersection, depenetration and containment between sets of groups.

All collider instances are zero-allocation after construction; simplicity and zero-allocation have been prioritized over raw speed. Rotations are given in radians, and are destructive: Rotating a shape changes the list of points that constitutes the collision geometry, and so a second rotation of a shape rotates the already rotated shape, not the initial shape.

#### Colliders
Quick overview of the features of the different colliders:

#### Base classes
| AbstractCollider | ShapeCollider |
|:---:|:---:|
| Abstract base of all colliders | Abstract base of RectangleCollider and PolygonCollider |

#### Derived classes
| Feature | RectangleCollider | PolygonCollider | CircleCollider |
|---|:---:|:---:|:---:|
| AABB | Yes | Yes | Yes |
| Scaling | No | Yes | Yes |
| Rotation | Yes | Yes | No |
| Set points | Yes | Yes | No |
| Debug visualization | Yes | Yes | Yes |
| Type of centre | Centre | Centroid | Centre |

_Note:_ Unrotated rectangles features an AABB-like collision test faster than polygon tests. Rotated rectangles are treated like polygons.

#### Collide
`Collide` features very simple generic interfaces for all its features. Types are resolved using pattern matching, and the interface _does what it says on the tin_. Collision is resolved directly without any broad or narrow phase candidate elimination, since it is assumed that you will be using the collision system if you want those features.

_Usage:_
```C#
PolygonCollider polygon = new PolygonCollider(new List<float2>() { new float2(-2, -1), new float2(2, -2), new float2(2, 3), new float2(0, 2), new float2(-2, 2) });
RectangleCollider rectangle = new RectangleCollider(3, 5);
CircleCollider circle = new CircleCollider(4);

polygon.SetPosition(new float2(1,3));
rectangle.SetPosition(new float2(1,2));
circle.SetPosition(new float2(3,1));

rectangle.SetRotation(math.radians(45));
polygon.SetRotation(math.radians(-22.5f));

//Each collider has an AABB for quick candidate elimination
bool aabbTest = Collide.Intersects(circle.aabb, polygon.aabb);

//The order of arguments does not matter in intersection tests
bool rectangleCircleIntersection = Collide.Intersects(rectangle, circle);
bool circleRectangleIntersection = Collide.Intersects(circle, rectangle);

bool polygonRectangleIntersection = Collide.Intersects(polygon, rectangle);
bool rectanglePolygonIntersection = Collide.Intersects(rectangle, polygon);

bool circlePolygonIntersection = Collide.Intersects(circle, polygon);
bool polygonCircleIntersection = Collide.Intersects(polygon, circle);

//Depenetration checks provides a valid depenetration vector for the first argument from the second argument
float2 polygonDepenetration = Collide.Depenetrate(polygon, rectangle);
float2 rectangleDepenetration = Collide.Depenetrate(rectangle, circle);
float2 circleDepenetration = Collide.Depenetrate(circle, polygon);

//Containment checks checks if the first argument is contained by the second
bool polygonContainedByCircle = Collide.ContainedBy(polygon, circle);
bool rectangleContainedByPolygon = Collide.ContainedBy(rectangle, polygon);
bool circleContainedByRectangle = Collide.ContainedBy(circle, rectangle);

//Raycasts are available for all shapes but do not yet report point of intersection
bool raycastIntersectsPolygon = Collide.Raycast(float2.zero, new float2(10, 7), polygon);
bool raycastIntersectsRectangle = Collide.Raycast(new float2(-5, 1), new float2(7, 1), rectangle);
bool raycastIntersectsCircle = Collide.Raycast(new float2(-1, 8), new float2(5, 3), circle);
bool raycastIntersectsLine = Collide.Raycast(new float2(-1,1), new float(3,2), new float2(5,2), new float2(6,0));
```
#### Collision system
The collision system is simple, and allows groups of colliders to be tested against each other. It features simple broad and narrow phases, and features a lookup system that mirrors the working of the `Collide` class explained above. The collision system loosely associates colliders with types. The collision system is entirely free-standing, but is used by the session management system. The goal is to offer maximum flexibility and ease of use, at the price of speed and implementation simplicity.

_Usage:_
```C#
CollisionSystem collisionSystem = new CollisionSystem(gridSize: 10, int groupCount = 5);

collisionSystem.AddCollisionGroup<Trigger>();
collisionSystem.AddCollisionGroup<Avatar>();
collisionSystem.AddCollisionGroup<Bullet>();
collisionSystem.AddCollisionGroup<Enemy>();
collisionSystem.AddCollisionGroup<World>();

collisionSystem.AddGroupToCheck<Avatar, Enemy>(containedBy: false, intersect: true, depenetrate: false);
collisionSystem.AddGroupToCheck<Bullet, Enemy>(containedBy: false, intersect: true, depenetrate: true);
collisionSystem.AddGroupToCheck<Avatar, World>(containedBy: false, intersect: true, depenetrate: true);
collisionSystem.AddGroupToCheck<Bullet, World>(containedBy: false, intersect: true, depenetrate: true);
collisionSystem.AddGroupToCheck<Enemy, World>(containedBy: false, intersect: true, depenetrate: true);
collisionSystem.AddGroupToCheck<Avatar, Trigger>(containedBy: true, intersect: true, depenetrate: false);

collisionSystem.AddCollider<Trigger>(goal.collider);
collisionSystem.AddCollider<Avatar>(avatar.collider);
collisionSystem.AddCollider<Bullet>(bullet.collider);
collisionSystem.AddCollider<Enemy>(enemy.collider);

for (int i = 0; world.colliders.Count > i; i++)
    collision.AddCollider<World>(world.colliders[i]);

collisionSystem.Update();

float2 avatarDepenetrateFromWorld = float2.zero;

for (int i = 0; world.colliders.Count > i; i++)
    avatarDepenetrateFromWorld += collisionSystem.Depenetrate(avatar.collider, world.colliders[i]);
    
bool avatarIntersectsEnemy = collisionSystem.Intersects(avatar, enemy);
bool bulletIntersectsEnemy = collisionSystem.Intersects(bullet, enemy);
bool avatarContainedByGoal = collisionSystem.ContainedBy(avatar, goal);
```

### Command system
The command system is a messaging system that builds a command queue that can be dispatched to entities after all commands have been issued. Commands can optionally be recorded and supports playback via the session management system. The command system is built around a state machine-esque abstraction called a `Routine` which consumes commands to modify its state. The `Routine` is intended as a way to encapsulate behaviour, and the command system is a way to control behaviours and record their state changes.

Both routines and commands are independent of the entity and session management systems, but the recorder depends on the session management system â€“ at least for now.

_Usage:_
```C#
public class Avatar : Entity, ICommandable
{
    public override void Activate() { }
    public override void Deactivate() => session.EnqueueCommand(new Move.Command(Routine.State.End);
    
    public override void Update()
    {
        float2 inputDirection = input.direction;
        bool2 compareInput = move.input != inputDirection;
        bool validInput = math.lengthsq(inputDirection) > 0;
        
        if ((move.state == Routine.State.Running && validInput && (compareInput.x || compareInput.y)) || (move.state != Routine.State.Running && validInput))
            session.EnqueueCommand(new Move.Command(Routine.State.Begin, input.direction);
        else if (move.state == Routine.State.Running && !validInput)
            session.EnqueueCommand(new Move.Command(Routine.State.End));
        
        move.Update();
    }
    
    public void Command<T>(T command) where T : struct, IRoutineHandleable
    {
        switch(command)
        {
            case Move.Command moveCommand:
                move.Handle(moveCommand);
        }
    }
    
    private Move move { get; }
    private Input input { get; }
    
    public Avatar()
    {
        move = new Move(this);
        input = new Input();
    }
    
    public class Move : Routine<Avatar, Move.Command>
    {
        public override void Update()
        {
            if (state != State.Running)
            {
                speed *= deceleration;
                
                if (minSpeed > speed)
                    speed = 0;
                
                velocity = math.normalizeSafe(velocity) * speed;
            }
            
            client.SetPosition(client.position + velocity);
            base.Update();
        }
        
        protected override void Begin(Command command) => input = command.input;
        
        protected override void Running() => velocity = input * (speed = math.clamp(speed * acceleration, minSpeed, maxSpeed));
        
        protected override void End(Command command) => input = command.input;
        
        public float2 input { get; private set; }
        
        private float2 velocity { get; set; }
        private float speed { get; set; }
        private float acceleration = 1.1f;
        private float deceleration = 0.8f;
        private float maxSpeed = 5;
        private float minSpeed = 2;
        
        public Move(Avatar client) : base(client) { }

        public struct Command : IRoutineHandleable
        {
            public float2 input { get; }
            public State state { get; }

            public Command(State state, float2 input = default)
            {
                this.state = state;
                this.input = input;
            }
        }
    }
}
```

### Entity management
A system for handling lifetime of pooled entities as well as collisions, commands, rendering, timing and update. The entity management system features a set of conveniences for entities that also ties into the game and UI management layers. It features all the facilities entities need to add and remove as well as iterate and message entity instances. Entity management deals with the handling of all the dependencies constituting a session. The idea is that a game may contain multiple sessions at the same time.

#### Entity
Very simple entity class with minimal set of features: material property block, position, rotation, scale, matrix4x4, timescale, id and active flag. Designed to be managed by the `Roster`, `Context` and `Session` stack and be drawn using the Tetra rendering stack.

#### Roster
Handles a pool of entities and all the active entity instances from that pool. Handles updating, adding and removing of instances as well as their time scale, which is stored locally and applied when an instance is fetched from the pool.

#### Context
Handles all the rosters in a session, providing the interfaces the session needs to interact with the rosters.

#### Session
The session handles all the components necessary to drive a game:

+ UI
+ Timing
+ Cameras
+ Entities
+ Recorder
+ Rendering
+ Command system
+ Collision system

The session is managed by the `Game` layer, which is intended to construct all the dependencies the `Session` handles. The session features convenience methods for the command system, recorder, context/roster/entity stack, cameras and the collision system.

The session is intended to restrict entities' access to the game system, promoting encapsulation by preventing the entities' from accessing most of the state in the game system. The Instead, the `Game` layer should observe the state of the session and contain the logic not directly related to entity behaviour.

#### Game management
