# Tetra
### An opinion on how to make games in Unity
---
### Overview
Tetra is a framework that abstracts away a lot of Unity's rather opinionated coding style and replaces it with _my_ rather opinionated coding style. It also features stand-alone components that can be used outside the rest of the framework. It provides simple, allocation-free solutions for common problems in something approaching idiomatic modern C#.

In short, the goal of Tetra is to no longer have to write `using UnityEngine;` at the top of your classes.

### Features

+ Caching
+ Collections
+ 2D Collision detection and resolution
+ Command system
+ Entity management
+ Rendering
+ Session management
+ Splines
+ Timing
+ Tweening
+ UI management

### Caching
The only caching solution is a very simple generic pool. 

#### Pool
Instances are generated by a delegate and stored on a stack. The pool features an abstract subclass so pools can be handled generically, but a type argument is necessary to both get and put instances. The pool automatically resizes if the pool is empty and an instance is requested.

_Usage:_

```C#
Pool<PooledType> pool = new Pool<Type>(() => new PooledType(), capacity)
PooledType pooledType = pool.Get();
pool.Put(pooledType);
```

### Collections
The only new collection is a simple, `List<T>`-backed PriorityQueue.

#### PriorityQueue
Useful for algorithms like A*, a priority queue takes an instance and an associated priority, and the new instance is automatically sorted into the queue by priority.

_Usage:_

```C#
PriorityQueue<QueuedType> priorityQueue = new PriorityQueue<QueuedType>(capacity);

QueuedType instanceA = new QueuedType();
QueuedType instanceB = new QueuedType();
QueuedType instanceC = new QueuedType();

priorityQueue.Enqueue(instanceA, 3);
priorityQueue.Enqueue(instanceB, 1);
priorityQueue.Enqueue(instanceC, 2);

QueuedType peekedInstanceB = priorityQueue.Peek();

QueuedType dequeuedInstanceB = priorityQueue.Dequeue();
QueuedType dequeuedInstanceC = priorityQueue.Dequeue();
QueuedType dequeuedInstanceA = priorityQueue.Dequeue();
```

### 2D Collision
A fast and simple collision detection system based on the separating axis theorem (SAT) that depends on Unity's SIMD-optimized mathematics library (https://github.com/Unity-Technologies/Unity.Mathematics). It features a static class that resolves:

+ AABB intersection
+ Raycasting against colliders
+ Point contained by AABB/collider
+ Collider intersects another collider
+ Collider contained by another collider
+ Depenetration of two intersecting colliders

for the following:

+ Circles
+ Polygons
+ Rectangles

It also features a collision system that groups colliders by a given type and uses a simple space partitioning broad phase and an AABB narrow phase to efficiently prune the number of tests necessary to determine intersection, depenetration and containment between sets of groups.

All collider instances are zero-allocation after construction; simplicity and zero-allocation have been prioritized over raw speed. Rotations are given in radians, and are destructive: Rotating a shape changes the list of points that constitutes the collision geometry, and so a second rotation of a shape rotates the already rotated shape, not the initial shape.

#### Colliders
Quick overview of the features of the different colliders:

#### Base classes
| AbstractCollider | ShapeCollider |
|:---:|:---:|
| Abstract base of all colliders | Abstract base of RectangleCollider and PolygonCollider |

#### Derived classes
| Feature | RectangleCollider | PolygonCollider | CircleCollider |
|---|:---:|:---:|:---:|
| AABB | Yes | Yes | Yes |
| Scaling | No | Yes | Yes |
| Rotation | Yes | Yes | No |
| Set points | Yes | Yes | No |
| Debug visualization | Yes | Yes | Yes |
| Type of centre | Centre | Centroid | Centre |

_Note:_ Unrotated rectangles features an AABB-like collision test faster than polygon tests. Rotated rectangles are treated like polygons.

#### Collide
`Collide` features very simple generic interfaces for all its features. Types are resolved using pattern matching, and the interface _does what it says on the tin_. Collision is resolved directly without any broad or narrow phase candidate elimination, since it is assumed that you will be using the collision system if you want those features.

_Usage:_
```C#
PolygonCollider polygon = new PolygonCollider(new List<float2>() { new float2(-2, -1), new float2(2, -2), new float2(2, 3), new float2(0, 2), new float2(-2, 2) });
RectangleCollider rectangle = new RectangleCollider(3, 5);
CircleCollider circle = new CircleCollider(4);

polygon.SetPosition(new float2(1,3));
rectangle.SetPosition(new float2(1,2));
circle.SetPosition(new float2(3,1));

rectangle.SetRotation(math.radians(45));
polygon.SetRotation(math.radians(-22.5f));

//The order of arguments does not matter in intersection tests
bool rectangleCircleIntersection = Collide.Intersect(rectangle, circle);
bool circleRectangleIntersection = Collide.Intersect(circle, rectangle);

bool polygonRectangleIntersection = Collide.Intersect(polygon, rectangle);
bool rectanglePolygonIntersection = Collide.Intersect(rectangle, polygon);

bool circlePolygonIntersection = Collide.Intersect(circle, polygon);
bool polygonCircleIntersection = Collide.Intersect(polygon, circle);

//Depenetration checks provides a valid depenetration vector for the first argument from the second argument
float2 polygonDepenetration = Collide.Depenetrate(polygon, rectangle);
float2 rectangleDepenetration = Collide.Depenetrate(rectangle, circle);
float2 circleDepenetration = Collide.Depenetrate(circle, polygon);

//Containment checks checks if the first argument is contained by the second
bool polygonContainedByCircle = Collide.ContainedBy(polygon, circle);
bool rectangleContainedByPolygon = Collide.ContainedBy(rectangle, polygon);
bool circleContainedByRectangle = Collide.ContainedBy(circle, rectangle);

//Raycasts are available for all shapes but do not yet report point of intersection
bool raycastIntersectsPolygon = Collide.Raycast(float2.zero, new float2(10, 7), polygon);
bool raycastIntersectsRectangle = Collide.Raycast(new float2(-5, 1), new float2(7, 1), rectangle);
bool raycastIntersectsCircle = Collide.Raycast(new float2(-1, 8), new float2(5, 3), circle);
bool raycastIntersectsLine = Collide.Raycast(new float2(-1,1), new float(3,2), new float2(5,2), new float2(6,0));
```
